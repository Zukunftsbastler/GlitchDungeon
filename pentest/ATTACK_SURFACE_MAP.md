# ğŸ—ºï¸ ATTACK SURFACE MAP
## The Glitch Dungeon - Visualisierung der SicherheitslÃ¼cken

```mermaid
graph TB
    subgraph "Client Browser"
        A[ğŸ® Spieler] --> B[index.html]
        B --> C[JavaScript Code]
        C --> D{Name Input}
        C --> E{API Calls}
    end
    
    subgraph "Angriffsvektoren Client"
        D --> F1[âŒ XSS via Name<br/>< script >alert 1< /script >]
        E --> F2[âŒ Manipulated Payload<br/>Negative/Extreme Values]
        E --> F3[âŒ No HTTPS Enforcement<br/>Mixed Content]
    end
    
    subgraph "Network"
        E --> G[HTTP POST/GET]
        G --> H[Netlify Edge]
    end
    
    subgraph "Angriffsvektoren Network"
        G --> N1[âŒ No Rate Limiting<br/>10k+ Requests/sec]
        G --> N2[âŒ CORS: *<br/>Any Origin Allowed]
        G --> N3[âŒ No Request Size Limit<br/>10MB+ Payloads]
    end
    
    subgraph "Serverless Function"
        H --> I[leaderboard.js]
        I --> J{Input Processing}
        J --> K[Redis Operations]
    end
    
    subgraph "Angriffsvektoren Server"
        J --> S1[âŒ No Input Validation<br/>Any Type/Length]
        J --> S2[âŒ NoSQL Injection<br/>Array Index Manipulation]
        J --> S3[âŒ No Sanitization<br/>HTML Tags Pass Through]
        K --> S4[âŒ Connection Leak<br/>Memory Exhaustion]
        K --> S5[âŒ No Max Entries<br/>Unbounded Growth]
    end
    
    subgraph "Database"
        K --> L[(Redis)]
        L --> M[Leaderboard Data]
    end
    
    subgraph "Angriffsvektoren Database"
        L --> D1[âŒ Any Key Accessible<br/>Via Injection]
        M --> D2[âŒ No Data Expiration<br/>Fills Forever]
    end
    
    style F1 fill:#ff6b6b
    style F2 fill:#ff6b6b
    style F3 fill:#feca57
    style N1 fill:#ff6b6b
    style N2 fill:#feca57
    style N3 fill:#feca57
    style S1 fill:#ff6b6b
    style S2 fill:#ff6b6b
    style S3 fill:#ff6b6b
    style S4 fill:#feca57
    style S5 fill:#feca57
    style D1 fill:#ff6b6b
    style D2 fill:#feca57
```

## ğŸ¯ ANGRIFFSKETTE - WORST CASE SCENARIO

```mermaid
sequenceDiagram
    participant Attacker
    participant Client
    participant API
    participant Redis
    participant Victim
    
    Note over Attacker: Phase 1: XSS Injection
    Attacker->>Client: Spiel mit Name:<br/><script>steal_cookies()</script>
    Client->>API: POST /leaderboard<br/>name: "<script>..."
    API->>Redis: STORE unsanitized name
    Redis-->>API: OK
    API-->>Client: Score submitted
    
    Note over Victim: Phase 2: Victim spielt
    Victim->>API: GET /leaderboard
    API->>Redis: FETCH leaderboard
    Redis-->>API: Returns data with <script>
    API-->>Victim: JSON with XSS
    Victim->>Victim: Renders name in HTML
    Note over Victim: ğŸ’¥ SCRIPT EXECUTES!<br/>Cookies stolen
    
    Note over Attacker: Phase 3: DoS Attack
    loop 10000 times in 10 seconds
        Attacker->>API: POST /leaderboard<br/>huge payload
    end
    Note over API: ğŸ’£ Function Limits Exceeded
    Note over Attacker: ğŸ’° Your Netlify Bill Explodes
    
    Note over Attacker: Phase 4: NoSQL Injection
    Attacker->>API: POST /leaderboard<br/>class: -1
    API->>Redis: KEYS[undefined]
    Note over Redis: ğŸ’¥ Crash or Wrong Key
    Redis-->>API: Error / Wrong Data
```

## ğŸ›¡ï¸ DEFENSE IN DEPTH - NACH FIXES

```mermaid
graph LR
    subgraph "Layer 1: Client"
        A[User Input] --> B[sanitizeName]
        B --> C[Validated Input]
    end
    
    subgraph "Layer 2: Network"
        C --> D[HTTPS Only]
        D --> E[CORS Whitelist]
        E --> F[Size Limit 10KB]
    end
    
    subgraph "Layer 3: API Gateway"
        F --> G[Rate Limit<br/>10 req/min]
        G --> H[IP Tracking]
    end
    
    subgraph "Layer 4: Server Logic"
        H --> I[Type Validation]
        I --> J[Range Validation]
        J --> K[Sanitization]
        K --> L[Server Timestamp]
    end
    
    subgraph "Layer 5: Database"
        L --> M[Validated Data]
        M --> N[Connection Pool]
        N --> O[Auto-Cleanup]
    end
    
    style B fill:#00d2d3
    style E fill:#00d2d3
    style G fill:#00d2d3
    style I fill:#00d2d3
    style J fill:#00d2d3
    style K fill:#00d2d3
    style N fill:#00d2d3
    style O fill:#00d2d3
```

## ğŸ” SECURITY LAYERS ERKLÃ„RT

### Layer 1: Client-Side Defense
- **sanitizeName()**: Entfernt HTML-Tags und gefÃ¤hrliche Zeichen
- **generateUID()**: Sichere UID-Generierung mit crypto API
- **Hardcoded HTTPS**: Verhindert Mixed Content Attacks

### Layer 2: Network Defense
- **CORS Whitelist**: Nur erlaubte Domains kÃ¶nnen API aufrufen
- **Request Size Limit**: Max 10KB verhindert Memory DoS
- **HTTPS Enforcement**: Keine unverschlÃ¼sselten Ãœbertragungen

### Layer 3: API Gateway Defense
- **Rate Limiting**: Max 10 Requests pro Minute pro IP
- **IP Tracking**: Erkennt wiederholte Angriffe
- **Method Validation**: Nur GET/POST erlaubt

### Layer 4: Server Logic Defense
- **Type Validation**: PrÃ¼ft ob String, Number, etc.
- **Range Validation**: Depth 0-1000, Moves > 0, etc.
- **Sanitization**: Entfernt XSS-Payloads serverseitig
- **Server Timestamp**: Client kann Timestamp nicht fÃ¤lschen

### Layer 5: Database Defense
- **Connection Pooling**: Verhindert Connection Exhaustion
- **Auto-Cleanup**: Top 5 Only, alte EintrÃ¤ge werden gelÃ¶scht
- **Expiration**: Redis Keys expiren nach 90 Tagen

## ğŸ“Š RISIKO-MATRIX

```mermaid
quadrantChart
    title Security Risk Matrix
    x-axis Low Impact --> High Impact
    y-axis Low Probability --> High Probability
    quadrant-1 Critical Risks (Fix Now!)
    quadrant-2 Monitor Closely
    quadrant-3 Accept
    quadrant-4 Mitigate When Possible
    XSS Attack: [0.8, 0.9]
    NoSQL Injection: [0.85, 0.7]
    DoS Attack: [0.9, 0.95]
    Connection Leak: [0.5, 0.6]
    Error Leakage: [0.3, 0.4]
    Missing CSP: [0.4, 0.3]
    Google Fonts: [0.2, 0.3]
```

## ğŸ¯ PRIORITÃ„TEN

```mermaid
pie title Fix Priority Distribution
    "Critical (Do Now)" : 45
    "High (Today)" : 30
    "Medium (This Week)" : 15
    "Low (Nice-to-Have)" : 10
```

---

## ğŸ’¡ KEY TAKEAWAYS

1. **Defense in Depth funktioniert!** 
   - Mehrere Schichten fangen auf, was eine Ã¼bersieht

2. **Client-Side Validation ist NICHT genug**
   - Kann umgangen werden â†’ Server muss ALLES prÃ¼fen

3. **Rate Limiting ist essentiell**
   - SchÃ¼tzt vor DoS UND reduziert Kosten

4. **Sanitization an beiden Enden**
   - Client: FÃ¼r UX (direkte Fehler)
   - Server: FÃ¼r Security (letzte Verteidigung)

5. **Error Messages sind gefÃ¤hrlich**
   - KÃ¶nnen Systeminformationen leaken
   - In Production immer generic halten
