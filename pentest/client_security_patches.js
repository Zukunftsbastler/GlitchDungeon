// ========================================
// CLIENT-SIDE SECURITY PATCHES
// Diese Funktionen in die index.html einfügen
// ========================================

// 1. NAME SANITIZATION - XSS Prevention
// Füge diese Funktion VOR der ersten Verwendung von meta.name ein
// (z.B. nach der meta-Objekt Definition)

function sanitizeName(name) {
  if (!name || typeof name !== 'string') return 'Held';
  
  // Entferne HTML-Tags und gefährliche Zeichen
  const div = document.createElement('div');
  div.textContent = name;
  let safe = div.innerHTML;
  
  // Zusätzliche Bereinigung
  safe = safe
    .replace(/[<>'"&\/\\]/g, '')
    .replace(/\s+/g, ' ')
    .trim()
    .substring(0, 30);
  
  return safe || 'Held';
}

// 2. ERSETZE alle Stellen wo meta.name gesetzt wird:
// VORHER:
// meta.name = prompt("Dein Name?") || "Held";

// NACHHER:
// meta.name = sanitizeName(prompt("Dein Name?"));

// Beispiel für die Stelle beim Start (ca. Zeile 1264):
function startGame(cls) {
  sfx('select');
  meta.cls = cls;
  meta.name = sanitizeName(prompt("Dein Name?") || "Held"); // <-- GEÄNDERT
  // ... rest of code
}


// ========================================
// 3. API URL - Hardcode HTTPS
// Finde die API_URL Definition und ersetze sie:
// ========================================

// VORHER (unsicher):
// const API_URL = window.location.origin + '/.netlify/functions/leaderboard';

// NACHHER (sicher):
const API_URL = 'https://glitch-dungeon.netlify.app/.netlify/functions/leaderboard';
// WICHTIG: Ersetze 'glitch-dungeon' mit deinem echten Netlify-Subdomain!


// ========================================
// 4. ERROR HANDLING beim API-Call verbessern
// Finde die submitScore Funktion und verbessere sie:
// ========================================

async function submitScore() {
  try {
    const payload = [
      meta.name,           // Bereits sanitized durch sanitizeName()
      meta.cls,
      game.level,
      game.turnCount,
      stats.totalKills,
      stats.totalDeaths,
      stats.bestGear || 0,
      Date.now(),
      meta.uid
    ];
    
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ data: payload }),
      signal: AbortSignal.timeout(10000) // 10 Sekunden Timeout
    });
    
    if (!response.ok) {
      if (response.status === 429) {
        console.warn('Rate limit reached. Try again later.');
        return; // Stiller Fehler bei Rate Limit
      }
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    
    if (result.rank) {
      console.log(`Score submitted! Rank: ${result.rank}`);
    }
    
  } catch (error) {
    // Stiller Fehler - störe den Spielfluss nicht
    console.warn('Could not submit score:', error.message);
    // Optional: Zeige dezente Nachricht
    // addParticle(320, 320, "Score offline gespeichert", '#888');
  }
}


// ========================================
// 5. LEADERBOARD RENDERING - XSS Prevention beim Anzeigen
// Wenn du Leaderboard-Daten vom Server anzeigst:
// ========================================

function displayLeaderboard(data) {
  // Wenn du Namen im HTML anzeigst, IMMER escapen:
  
  data.top.forEach((entry, index) => {
    const name = escapeHtml(entry[0]); // <-- Wichtig!
    const depth = entry[2];
    const moves = entry[3];
    const kills = entry[4];
    
    // Dann sicher ins DOM einfügen
    const row = document.createElement('div');
    row.textContent = `${index + 1}. ${name} - Tiefe ${depth}`;
    // ODER:
    row.innerHTML = `<span class="rank">${index + 1}.</span> 
                     <span class="name">${name}</span> 
                     <span class="depth">Tiefe ${depth}</span>`;
    
    leaderboardContainer.appendChild(row);
  });
}

// Helper Funktion zum HTML-Escaping
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}


// ========================================
// 6. ZUSÄTZLICHE VALIDIERUNGEN für Leaderboard-Daten
// ========================================

async function fetchLeaderboard(classIdx) {
  try {
    // Validiere Input
    if (classIdx < 0 || classIdx > 2) {
      console.error('Invalid class index');
      return null;
    }
    
    const response = await fetch(
      `${API_URL}?class=${encodeURIComponent(classIdx)}`,
      {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: AbortSignal.timeout(5000)
      }
    );
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    // Validiere Response-Struktur
    if (!data.top || !Array.isArray(data.top)) {
      console.error('Invalid leaderboard response');
      return null;
    }
    
    return data;
    
  } catch (error) {
    console.warn('Could not fetch leaderboard:', error.message);
    return null;
  }
}


// ========================================
// 7. CONTENT SECURITY POLICY (Optional)
// Füge im <head> ein (für zusätzliche Sicherheit):
// ========================================
/*
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://glitch-dungeon.netlify.app;
  img-src 'self' data:;
">
*/


// ========================================
// 8. UID GENERATION - Sicherstellen dass UID konsistent ist
// ========================================

function generateUID() {
  // Prüfe ob UID bereits existiert
  let uid = localStorage.getItem('GD_UID');
  
  if (!uid) {
    // Generiere neue UID mit Crypto API (wenn verfügbar)
    if (window.crypto && window.crypto.randomUUID) {
      uid = window.crypto.randomUUID();
    } else {
      // Fallback für ältere Browser
      uid = 'uid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    localStorage.setItem('GD_UID', uid);
  }
  
  return uid;
}

// Verwende beim Start:
meta.uid = generateUID();


// ========================================
// ZUSAMMENFASSUNG - ÄNDERUNGEN IN index.html:
// ========================================

/*
1. Füge sanitizeName() Funktion hinzu (nach meta = {...} Definition)
2. Ersetze ALLE meta.name Zuweisungen mit: meta.name = sanitizeName(...)
3. Hardcode API_URL mit deiner Netlify-Domain
4. Verbessere submitScore() Error Handling
5. Füge escapeHtml() für Leaderboard-Rendering hinzu
6. Verwende generateUID() statt einfachem Date.now()
7. Optional: CSP Meta-Tag im <head>

WICHTIG: Teste nach jeder Änderung, dass das Spiel noch funktioniert!
*/
